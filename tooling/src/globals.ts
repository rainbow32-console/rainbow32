export default "interface fn {\n    /**\n     * calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\n     * @param thisArg the object to be used as the this object.\n     * @param argArray a set of arguments to be passed to the function.\n     */\n    apply(this: fn, thisarg: any, argarray?: any): any;\n    /**\n     * calls a method of an object, substituting another object for the current object.\n     * @param thisarg the object to be used as the current object.\n     * @param argarray a list of arguments to be passed to the method.\n     */\n    call(this: fn, thisarg: any, ...argarray: any[]): any;\n    /**\n     * for a given function, creates a bound function that has the same body as the original function.\n     * the this object of the bound function is associated with the specified object, and has the specified initial parameters.\n     * @param thisArg an object to which the this keyword can refer inside the new function.\n     * @param argArray a list of arguments to be passed to the new function.\n     */\n    bind(this: fn, thisarg: any, ...argarray: any[]): any;\n    readonly name: string;\n    readonly length: number;\n}\ninterface Function extends fn {\n}\ninterface String {\n    length: number;\n    repeat(amount: number): string;\n}\ninterface array<t> {\n    readonly length: number;\n    [index: number]: t;\n    push(...values: t[]): number;\n    unshift(...values: t[]): number;\n    pop(): void;\n    shift(...values: t[]): void;\n}\ninterface Array<t> extends array<t> {\n}\ninterface promiselike<t> {\n    /**\n     * attaches callbacks for the resolution and/or rejection of the promise.\n     * @param onfulfilled the callback to execute when the promise is resolved.\n     * @param onrejected the callback to execute when the promise is rejected.\n     * @returns a promise for the completion of which ever callback is executed.\n     */\n    then<tres1 = t, tres2 = never>(onfulfilled?: ((value: t) => tres1 | promiselike<tres1>) | undefined | null, onrejected?: ((reason: any) => tres2 | promiselike<tres2>) | undefined | null): promiselike<tres1 | tres2>;\n}\ninterface promise<t> {\n    /**\n     * attaches callbacks for the resolution and/or rejection of the promise.\n     * @param onfulfilled the callback to execute when the promise is resolved.\n     * @param onrejected the callback to execute when the promise is rejected.\n     * @returns a promise for the completion of which ever callback is executed.\n     */\n    then<tres1 = t, tres2 = never>(onfulfilled?: ((value: t) => tres1 | promiselike<tres1>) | undefined | null, onrejected?: ((reason: any) => tres2 | promiselike<tres2>) | undefined | null): promise<tres1 | tres2>;\n    /**\n     * attaches a callback for only the rejection of the promise.\n     * @param onrejected the callback to execute when the promise is rejected.\n     * @returns a promise for the completion of the callback.\n     */\n    catch<tres = never>(onrejected?: ((reason: any) => tres | promiselike<tres>) | undefined | null): promise<t | tres>;\n}\ntype awaited<t> = t extends null | undefined ? t : t extends object & {\n    then(onfulfilled: infer f): any;\n} ? f extends (value: infer v, ...args: any) => any ? awaited<v> : never : t;\ninterface Promise<t> extends promise<t> {\n}\ndeclare const promise: {\n    /**\n     * creates a promise that is resolved with an array of results when all of the provided promises\n     * resolve, or rejected when any promise is rejected.\n     * @param values an iterable of promises.\n     * @returns a new promise.\n     */\n    all<t>(values: promiselike<t>[]): promise<awaited<t>[]>;\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An iterable of Promises.\n     * @returns A new Promise.\n     */\n    race<t>(values: promiselike<t>[]): promise<awaited<t>>;\n    /**\n     * creates a new promise.\n     * @param executor a callback used to initialize the promise. this callback is passed two arguments:\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\n     * and a reject callback used to reject the promise with a provided reason or error.\n     */\n    new <t>(executor: (resolve: (value: t | promiselike<t>) => void, reject: (reason?: any) => void) => void): promise<t>;\n    /**\n     * creates a new rejected promise for the provided reason.\n     * @param reason the reason the promise was rejected.\n     * @returns a new rejected Promise.\n     */\n    reject<t = never>(reason?: any): promise<t>;\n    /**\n     * Creates a new resolved promise.\n     * @returns A resolved promise.\n     */\n    resolve(): promise<void>;\n    /**\n     * Creates a new resolved promise for the provided value.\n     * @param value A promise.\n     * @returns A promise whose internal state matches the provided promise.\n     */\n    resolve<t>(value: t | promiselike<t>): promise<t>;\n};\ndeclare const Promise: {\n    new <t>(executor: (resolve: (value: t | promiselike<t>) => void, reject: (reason?: any) => void) => void): promise<t>;\n    /**\n     * creates a promise that is resolved with an array of results when all of the provided promises\n     * resolve, or rejected when any promise is rejected.\n     * @param values an iterable of promises.\n     * @returns a new promise.\n     */\n    all<t_1>(values: promiselike<t_1>[]): promise<awaited<t_1>[]>;\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An iterable of Promises.\n     * @returns A new Promise.\n     */\n    race<t_2>(values: promiselike<t_2>[]): promise<awaited<t_2>>;\n    /**\n     * creates a new rejected promise for the provided reason.\n     * @param reason the reason the promise was rejected.\n     * @returns a new rejected Promise.\n     */\n    reject<t_3 = never>(reason?: any): promise<t_3>;\n    /**\n     * Creates a new resolved promise.\n     * @returns A resolved promise.\n     */\n    resolve(): promise<void>;\n    /**\n     * Creates a new resolved promise.\n     * @returns A resolved promise.\n     */\n    resolve<t_4>(value: t_4 | promiselike<t_4>): promise<t_4>;\n};\ndeclare const globalthis: any;\ninterface arraylike<t> {\n    readonly length: number;\n    readonly [n: number]: t;\n}\ninterface arraylikereadable<t> {\n    readonly length: number;\n    [n: number]: t;\n}\ninterface typedarrayconstructor<t> {\n    readonly prototype: t;\n    new (length: number): t;\n    new (array: arraylike<number>): t;\n    new (buffer: arraybuffer, byteOffset?: number, length?: number): t;\n    /**\n     * returns a new array from a set of elements.\n     * @param items a set of elements to include in the new array object.\n     */\n    of(...items: number[]): t;\n    /**\n     * creates an array from an array-like or iterable object.\n     * @param arraylike an array-like or iterable object to convert to an array.\n     */\n    from(arraylike: arraylike<number>): t;\n    /**\n     * creates an array from an array-like or iterable object.\n     * @param arraylike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisarg Value of 'this' used to invoke the mapfn.\n     */\n    from<t>(arraylike: arraylike<t>, mapfn: (v: t, k: number) => number, thisarg?: any): t;\n}\ninterface arraybuffer {\n    /**\n     * returns a section of an ArrayBuffer.\n     */\n    slice(begin: number, end?: number): arraybuffer;\n}\ninterface uint8array {\n    [index: number]: number;\n    readonly buffer: arraybuffer;\n    readonly length: number;\n}\ninterface uint8clampedarray {\n    [index: number]: number;\n    readonly buffer: arraybuffer;\n    readonly length: number;\n}\ninterface json {\n    /**\n     * converts a javascript object notation (json) string into an object.\n     * @param text a valid json string.\n     * @param reviver a function that transforms the results. This function is called for each member of the object.\n     * if a member contains nested objects, the nested objects are transformed before the parent object is.\n     */\n    parse(text: string, reviver?: (this: any, key: string, value: any) => any): any;\n    /**\n     * converts a javascript value to a javascript object Notation (json) string.\n     * @param value a javascript value, usually an object or array, to be converted.\n     * @param replacer a function that transforms the results.\n     * @param space adds indentation, white space, and line break characters to the return-value json text to make it easier to read.\n     */\n    stringify(value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string;\n    /**\n     * converts a javascript value to a javascript object Notation (JSON) string.\n     * @param value a javascript value, usually an object or array, to be converted.\n     * @param replacer an array of strings and numbers that acts as an approved list for selecting the object properties that will be stringified.\n     * @param space adds indentation, white space, and line break characters to the return-value json text to make it easier to read.\n     */\n    stringify(value: any, replacer?: (number | string)[] | null, space?: string | number): string;\n}\ndeclare const uint8array: typedarrayconstructor<uint8array>;\ndeclare const uint8clampedarray: typedarrayconstructor<uint8clampedarray>;\ntype partial<t> = {\n    [p in keyof t]?: t[p] | undefined;\n};\ntype propertykey = string | number | symbol;\ntype record<k extends propertykey, v> = {\n    [p in k]: v;\n};\ndeclare const number: (value: any) => number;\ndeclare const json: json;\ndeclare function tostring(value: any): string;\ndeclare const tostr: typeof tostring;\ndeclare const sqrt: (x: number) => number;\ndeclare const flr: (x: number) => number;\ndeclare const ceil: (x: number) => number;\ndeclare const abs: (x: number) => number;\ndeclare const sin: (x: number) => number;\ndeclare const cos: (x: number) => number;\ndeclare const tan: (x: number) => number;\ndeclare const atan2: (x: number) => number;\ndeclare const max: (...values: number[]) => number;\ndeclare const min: (...values: number[]) => number;\ndeclare const mid: (x: number, y: number, z: number) => number;\ndeclare const sgn: (x: number) => 1 | -1;\ndeclare const math: Math;\ndeclare const keys: (val: object) => string[];\ndeclare const pairs: <t>(o: {\n    [s: string]: t;\n} | arraylike<t>) => [string, t][];\ndeclare const entries: <t>(o: {\n    [s: string]: t;\n} | arraylike<t>) => [string, t][];\ndeclare const values: <t>(o: {\n    [s: string]: t;\n} | arraylike<t>) => t[];\ndeclare function rnd<t>(value: arraylike<t>): t;\ndeclare function rnd(value: string): string;\ndeclare function rnd(value: number): number;\ndeclare const playsound: (sound: sound, instrument: instrument, vol: number, time: number) => promise<void>;\ndeclare const playaudio: (audio: audio, timePerNote: number, vol: number) => promise<void>;\n/**\n * Returns the volume [0..100]\n */\ndeclare const getvolume: () => number;\ndeclare const storetofile: (obj: any, prefix?: string) => void;\ndeclare const readfromfile: <t>(prefix?: string) => t | undefined;\ndeclare const addparticle: (life: number, pos: vec2, size: number, color: number, gravity: number, force: vec2, oob?: boolean, mask?: imagemask) => particle;\ndeclare const removeparticle: (p: particle) => void;\ndeclare const removeparticles: () => void;\ndeclare const renderparticles: () => void;\ndeclare const __menu: {\n    resetentries: () => void;\n    setentry: (index: number, entry?: menuentry) => void;\n    removentry: (index: number) => void;\n};\ndeclare const parseimage: (img: string) => image;\ndeclare const parsemask: (mask: string) => imagemask;\ndeclare const defaultpalette: colorpalette;\ndeclare const imageutils: {\n    cls: () => void;\n    parseimage: (img: string) => image;\n    applyimagemask: (image: image, mask: imagemask) => image;\n    applyimagemaskmodifyimage: (image: image, mask: imagemask) => image;\n    circle: (radius: number, color: number | string) => image;\n    square: (width: number, height: number, color: number | string) => image;\n    defaultpalette: colorpalette;\n    getcolor: (color: number) => record<'a' | 'b' | 'g' | 'r', number>;\n    getcurrentpalette: () => colorpalette;\n    isvalidcolor: (color: number) => boolean;\n    parsemask: (mask: string) => imagemask;\n    putimage: (x: number, y: number, image: image) => void;\n    putimageraw: (x: number, y: number, image: image) => void;\n    setcurrentpalette: (palette: colorpalette) => void;\n    stringifyimage: (img: image) => string;\n    stringifymask: (mask: imagemask) => string;\n    serializeimage: (img: image) => Uint8Array;\n    unserializeimage: (img: Uint8Array) => image;\n    imgtopng: (image: image, type?: 'image/png' | 'image/jpeg' | 'image/webp' | undefined) => string;\n    setoffset: (x: number, y: number) => void;\n    setpixel: (x: number, y: number, color: number | string) => void;\n    line: (x1: number, y1: number, x2: number, y2: number, col: number) => void;\n};\ndeclare const dist: (x1: number, y1: number, x2: number, y2: number) => number;\ndeclare const lerp: (p0: number, p1: number, t: number) => number;\ndeclare const mem: Uint8Array;\ndeclare const buttons: record<button, {\n    down: boolean;\n    press: boolean;\n}>;\ndeclare const stopgame: () => promise<void>;\ndeclare const screen: {\n    height: number;\n    width: number;\n};\ndeclare const scene: new <t>(scene: userscene<t>) => scene;\ndeclare const scenemanager: scenemanager;\ndeclare const gameobject: new (opts: gameobjopts) => gameobject;\ndeclare const createcomponent: <t>(component: component<t>, data?: partial<t> | undefined) => componententry<t>;\ndeclare const component: <t>(component: component<t>, data?: partial<t> | undefined) => componententry<t>;\ndeclare const comp: <t>(component: component<t>, data?: partial<t> | undefined) => componententry<t>;\ndeclare const imagerenderer: component<void>;\ndeclare const boxcollider: component<{\n    width: number;\n    height: number;\n    oldCollisions: gameobject[];\n}>;\ndeclare const download: (url: string, name: string) => void;\ndeclare const isontimeout: (name: string) => boolean;\ndeclare const timeout: (name: scene, ms: number) => void;\ndeclare const nextframe: () => promise<void>;\ndeclare const fonts: {\n    [name: string]: font;\n};\ndeclare const currenttextmasks: font;\ndeclare const textutils: {\n    addcharmap: (char: string, mask: imagemask) => void;\n    applycharmap: (font: font) => void;\n    clearcharmap: () => void;\n    calculatebounds: (text: string, x: number, y: number, maxWidth: number, opts?: {\n        spaceWidth?: number;\n        centered?: boolean;\n    }) => line[];\n    calculatewidth: (text: string, spaceWidth?: number) => number;\n    writetext: (text: string, x: number, y: number, maxWidth: number, opts?: {\n        color?: number;\n        background?: number;\n        spaceWidth?: number;\n        centered?: boolean;\n    }) => line[];\n};\ntype instrument = 'square-wave' | 'sine-wave' | 'triangle-wave' | 'sawtooth-wave' | 'noise';\ninterface audio {\n    channel1: Uint8Array;\n    channel2: Uint8Array;\n    channel3: Uint8Array;\n    channel4: Uint8Array;\n    channel1instrument: instrument;\n    channel2instrument: instrument;\n    channel3instrument: instrument;\n    channel4instrument: instrument;\n    length: number;\n}\ninterface sound {\n    octave: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\n    sound: 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g';\n    sharp: boolean;\n}\ninterface particle {\n    end: number;\n    pos: vec2;\n    image: image;\n    gravity: number;\n    force: vec2;\n    fallsOOB: boolean;\n}\ninterface vec2 {\n    x: number;\n    y: number;\n}\ninterface vec3 {\n    x: number;\n    y: number;\n    z: number;\n}\ninterface vec4 {\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n}\ninterface imagemask {\n    width: number;\n    height: number;\n    buf: uint8array;\n}\ninterface image {\n    width: number;\n    height: number;\n    buf: uint8array;\n}\ninterface menuentry {\n    name: string;\n    callback: () => any;\n}\ntype colorpalette = [\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string\n];\ntype button = 'up' | 'down' | 'left' | 'right' | 'u' | 'i' | 'o' | 'p';\ndeclare const buttonids: Readonly<button[]>;\ninterface userscene<t> {\n    beforeinit(scene: scene): t;\n    afterinit?(config: t, scene: scene): void;\n    beforeupdate?(config: t, scene: scene, dt: number): void;\n    afterupdate?(config: t, scene: scene, dt: number): void;\n    beforeremove?(config: t, scene: scene): void;\n    afterremove?(config: t, scene: scene): void;\n    objects: gameobject[];\n    name: string;\n}\ninterface scene {\n    objects: gameobject[];\n    addobjects(...obj: gameobject[]): void;\n    getobjectbyname(name: string): gameobject | undefined;\n    getobjectsbyname(name: string): gameobject[];\n    removeobject(object: gameobject): void;\n    removeobjects(...objects: gameobject[]): void;\n    removeobjectsbyname(name: string): void;\n    removeobjectsbynames(...name: string[]): void;\n}\ninterface scenemanager {\n    setscenes(scenes: scene[], defaultselected?: number): void;\n    addscene(scene: scene): void;\n    changescene(scene: string | number): void;\n    getscene(): scene | undefined;\n}\ninterface transform {\n    position: vec2;\n}\ninterface component<config = void> {\n    init(config: partial<config> | undefined, gameobject: gameobject): config;\n    update?(config: config, dt: number, gameobject: gameobject): void;\n    remove?(config: config, gameobject: gameobject): void;\n    readonly name: string;\n}\ninterface gameobjopts {\n    name: string;\n    image: image | animation<image> | string;\n    mask?: imagemask | animation<imagemask> | string;\n    components?: componententry<any>[];\n    opacity?: number;\n    transform?: partial<transform>;\n    customrenderer?: boolean;\n    events?: record<string, (obj: gameobject, ...args: any[]) => void>;\n    eventsonce?: record<string, (obj: gameobject, ...args: any[]) => void>;\n}\ntype componententry<t> = {\n    component: component<t>;\n    config?: partial<t>;\n};\ninterface gameobject {\n    readonly name: string;\n    readonly lifetime: number;\n    transform: transform;\n    image: image | animation<image>;\n    mask?: imagemask | animation<imagemask>;\n    active: boolean;\n    addcomponents<t>(components: componententry<t>[]): void;\n    removecomponent(component: string): void;\n    getcomponent<t extends component<any>>(component: string): t | undefined;\n    getcomponentdata<t extends component<any>>(component: string): Required<Parameters<t['init']>[0]> | undefined;\n    off(name: string, cb: (obj: gameobject, ...args: any[]) => void): void;\n    once(name: string, cb: (obj: gameobject, ...args: any[]) => void): void;\n    on(name: string, cb: (obj: gameobject, ...args: any[]) => void): void;\n    emitevent(name: string, args: any[]): void;\n}\ntype font = record<string, imagemask>;\ninterface line {\n    y: number;\n    start: number;\n    end: number;\n}\ndeclare function square(x: number, y: number, width: number, height: number, color: number | string, mask?: imagemask, filled?: boolean): void;\ndeclare function circle(x: number, y: number, radius: number, color: number | string, mask?: imagemask): void;\ndeclare function scaleimg(scale: number, image: image): image;\ndeclare function spr(x: number, y: number, image: image, scale?: number, dontblend?: boolean): void;\ndeclare function del<t>(arr: t[], value: t): void;\ninterface error {\n    name: string;\n    message: string;\n    stack?: string;\n}\ninterface errorconstructor {\n    new (message?: string): error;\n    (message?: string): error;\n    readonly prototype: error;\n}\ndeclare const error: errorconstructor;\ndeclare function isarr(value: any): boolean;\ndeclare function font(font?: font | string): void;\ndeclare const pal: (color1?: number, color2?: number) => void;\ndeclare function palt(color: number, transparent: boolean): void;\ndeclare function camera(x?: number, y?: number): void;\ndeclare function noop(): void;\ndeclare function menu(index: number, name?: string, callback?: () => void): void;\ndeclare const cls: () => void;\ndeclare const setp: (x: number, y: number, color: number | string) => void;\ninterface gamefile {\n    name: string;\n    init?(): void;\n    update?(dt: number): void;\n    remove?(): void;\n    scenes?: scene[];\n    defaultScene?: number;\n}\ndeclare function registergame(game: gamefile): void;\ndeclare function btn(button: button): boolean;\ndeclare function btnp(button: button): boolean;\ndeclare const U: button;\ndeclare const D: button;\ndeclare const L: button;\ndeclare const R: button;\ndeclare function substr(str: string, start: number, end?: number): string;\ndeclare function sub(str: string, start: number, end?: number): string;\ndeclare function tonum(str: string): number;\ndeclare function split(str: string, seperator?: string): string[];\ndeclare function cursor(x?: number, y?: number): void;\ndeclare const infinity: number;\ndeclare function print(text: string, color?: number, background?: number, x?: number, y?: number, spacewidth?: number, centered?: boolean): void;\ndeclare function find<t>(arr: arraylike<t>, predicate: (el: t, i: number) => boolean): t | undefined;\ndeclare function findindex<t>(arr: arraylike<t>, predicate: (el: t, i: number) => boolean): number | undefined;\ndeclare function indexof<t>(arr: arraylike<t>, value: t): number | undefined;\ndeclare function includes<t>(arr: arraylike<t>, value: t): boolean;\ndeclare function reduce<t, k>(arr: arraylike<t>, cb: (a: k, b: t) => k, defaultvalue: k): k;\ndeclare function filter<t>(arr: arraylike<t>, predicate: (el: t, index: number, arr: arraylike<t>) => boolean): t[];\ndeclare function map<t, k>(arr: arraylike<t>, predicate: (el: t, index: number, arr: arraylike<t>) => k): k[];\ndeclare function mmap<t, k>(arr: arraylikereadable<t>, predicate: (el: t, index: number, arr: arraylikereadable<t>) => t): void;\ndeclare class arraypipe<t> {\n    private array;\n    private steps;\n    constructor(arr: arraylike<t>, steps?: {\n        type: 'filter' | 'map';\n        predicate: (el: t, index: number) => boolean | t;\n    }[]);\n    map<k>(predicate: (el: t, index: number) => k): arraypipe<k>;\n    filter(predicate: (el: t, index: number) => boolean): this;\n    execute(): t[];\n}\ndeclare const log: (...args: any[]) => void;\ndeclare const logerr: (...args: any[]) => void;\ndeclare const logwarn: (...args: any[]) => void;\ndeclare const loginfo: (...args: any[]) => void;\ndeclare function count(value: arraylike<any> | string): number;\ndeclare function cursorpos(): vec2;\ndeclare const settimeout: (cb: () => any, ms: number) => number;\ndeclare const setinterval: (cb: () => any, ms: number) => number;\ndeclare const clearinterval: (id: number) => void;\ndeclare const cleartimeout: (id: number) => void;\ndeclare function add<t>(arr: t[], ...values: t[]): void;\ndeclare const now: () => number;\ndeclare function join(arr: arraylike<any>, seperator?: string): string;\ndeclare const u = \"u\";\ndeclare const i = \"i\";\ndeclare const o = \"o\";\ndeclare const p = \"p\";\ndeclare function sleep(ms: number): promise<void>;\ndeclare function type(value: any): \"string\" | \"number\" | \"bigint\" | \"boolean\" | \"symbol\" | \"undefined\" | \"object\" | \"function\" | \"null\" | \"array\";\ndeclare const line: (x1: number, y1: number, x2: number, y2: number, col: number) => void;\ndeclare const getcolorhex: (color: number) => record<'a' | 'b' | 'g' | 'r', number>;\ninterface effect<t> {\n    update(dt: number, val: t, effect: effect<t> & {\n        value: t;\n    }): void;\n    init(val: t, effect: effect<t> & {\n        value: t;\n    }): void;\n    remove(val: t, effect: effect<t> & {\n        value: t;\n    }): void;\n    name: string;\n}\ntype effectfunction<t> = effect<t>['update'];\ntype color = record<'r' | 'g' | 'b' | 'a', number>;\ninterface renderer<t> {\n    update(realcolor: color, color: number, val: t, renderer: renderer<t> & {\n        value: t;\n    }): color;\n    init(val: t, renderer: renderer<t> & {\n        value: t;\n    }): void;\n    remove(val: t, renderer: renderer<t> & {\n        value: t;\n    }): void;\n    name: string;\n}\ntype rendererfunction<t> = renderer<t>['update'];\ndeclare const createeffect: <t>(name: string, update: (dt: number, val: t, effect: effect<t> & {\n    value: t;\n}) => void, init?: ((val: t, effect: effect<t> & {\n    value: t;\n}) => void) | undefined, remove?: ((val: t, effect: effect<t> & {\n    value: t;\n}) => void) | undefined) => effect<t>;\ndeclare const applyeffect: <t>(effect: effect<t>, value: t) => void;\ndeclare const removeeffect: (effect: string | effect<any>) => void;\ndeclare const createrenderer: <t>(name: string, update: (realcolor: color, color: number, val: t, renderer: renderer<t> & {\n    value: t;\n}) => color, init?: ((val: t, effect: renderer<t> & {\n    value: t;\n}) => void) | undefined, remove?: ((val: t, effect: renderer<t> & {\n    value: t;\n}) => void) | undefined) => renderer<t>;\ndeclare const applyrenderer: <t>(renderer: renderer<t>, value: t) => void;\ndeclare const removerenderer: (renderer: string | renderer<any>) => void;\ndeclare const effects: {\n    screenshake: effect<number>;\n    oldcolors: effect<undefined>;\n};\ndeclare const renderers: {\n    bwcolors: renderer<number>;\n};\ninterface animationframe<t> {\n    time: number;\n    value: t;\n}\ntype animation<t> = animationframe<t>[];\ninterface animationplayer<t> {\n    start(): void;\n    play(): void;\n    stop(): void;\n    recomputemaxlength(): void;\n    getframe(): t | undefined;\n    setanimations(animation: animation<t>): void;\n    callback(cb?: ((frame: t) => void) | undefined): void;\n    toggleplay(): void;\n    readonly isplaying: boolean;\n}\ninterface animationbuilder<t> {\n    addframe(value: t, time: number): animationbuilder<t>;\n    build(): animation<t>;\n}\ndeclare const getanimationframe: <t>(animation: animation<t>, timefromstart: number) => t | undefined;\ndeclare const animationplayer: {\n    new <t>(animation: animation<t>): animationplayer<t>;\n    prototype: animationplayer<any>;\n} & fn;\ndeclare const animationbuilder: (new <t>() => animationbuilder<t>) & fn;\ndeclare function vec2(x: number, y: number): vec2;\ndeclare function vec2i(x: number, y: number): vec2;\ndeclare function vec3(x: number, y: number, z: number): vec3;\ndeclare function vec3i(x: number, y: number, z: number): vec3;\ndeclare function vec4(x: number, y: number, z: number, w: number): vec4;\ndeclare function vec4i(x: number, y: number, z: number, w: number): vec4;\ndeclare const getcurrentimage: (obj: gameobject) => image;\ndeclare const getcurrentimagemask: (obj: gameobject) => imagemask | undefined;\n{};\n"