export default "function importExposed(name: string): any {\n    return (globalThis as any)[name];\n}\n\n/**\n *\n * EXPORTS\n *\n */\n\nconst BoxCollider = importExposed('BoxCollider') as Component<{\n    width: number;\n    height: number;\n    oldCollisions: GameObject[];\n}>;\nfunction registerGame(game: GameFile): void {\n    (globalThis as any).__registeredGame = game;\n}\n\nconst fonts = importExposed('fonts') as Record<\n    'default' | 'default_monospace' | 'legacy',\n    Font\n>;\nconst imageUtils = importExposed('imageUtils') as ImageUtils;\nconst audioUtils = importExposed('audioUtils') as AudioUtils;\nconst utils = {\n    nextFrame: importExposed('nextFrame'),\n    download: importExposed('download'),\n    isOnTimeout: importExposed('isOnTimeout'),\n    timeout: importExposed('timeout'),\n} as Utils;\nconst ParticleSystem = {\n    addParticle: importExposed('addParticle') as (\n        life: number,\n        pos: Vec2,\n        size: number,\n        color: number,\n        gravity: number,\n        force: Vec2,\n        oob?: boolean,\n        mask?: ImageMask\n    ) => Particle,\n    removeParticle: importExposed('removeParticle') as (p: Particle) => void,\n    removeParticles: importExposed('removeParticles') as () => void,\n};\nconst ImageRenderer = importExposed('ImageRenderer') as Component<void>;\nconst createComponent = importExposed('createComponent') as <T>(\n    component: Component<T>,\n    data?: Partial<T>\n) => ComponentEntry<T>;\nconst component = importExposed('createComponent') as <T>(\n    component: Component<T>,\n    data?: Partial<T>\n) => ComponentEntry<T>;\nconst comp = importExposed('createComponent') as <T>(\n    component: Component<T>,\n    data?: Partial<T>\n) => ComponentEntry<T>;\nconst GameObject = importExposed('GameObject') as new (\n    opts: GameObjectOptions\n) => _GameObject;\nconst memory = importExposed('memory') as Uint8Array;\nconst isPressed = importExposed('isPressed') as (\n    button: Button\n) => boolean;\nconst buttons = importExposed('buttons') as Record<\n    Button,\n    {\n        down: boolean;\n        press: boolean;\n    }\n>;\nconst WIDTH = importExposed('WIDTH') as number;\nconst HEIGHT = importExposed('HEIGHT') as number;\nconst stopGame = importExposed('stopGame') as () => void;\nconst reset = importExposed('stopGame') as () => void;\nconst math = {\n    distance: importExposed('distance'),\n    lerp: importExposed('lerp'),\n} as _Math;\nconst saveFile = {\n    storeToFile: importExposed('storeToFile'),\n    readFromFile: importExposed('readFromFile'),\n} as SaveFileUtils;\nconst Scene = importExposed('Scene') as new <\n    T extends Record<string, any>\n>(\n    scene: UserScene<T>\n) => _Scene;\nconst SceneManager = importExposed('SceneManager') as _SceneManager;\nconst TextUtils = {\n    writeText: importExposed('writeText'),\n    currentTextMasks: importExposed('currentTextMasks'),\n    addCharacterMask: importExposed('addCharacterMask'),\n    applyCharacterMap: importExposed('applyCharacterMap'),\n    clearCharacterMap: importExposed('clearCharacterMap'),\n    calculateBounds: importExposed('calculateBounds'),\n    calculateWidth: importExposed('calculateWidth'),\n} as _TextUtils;\n\n/**\n *\n * TYPES\n *\n */\n\ntype ImageRenderer = typeof ImageRenderer;\ntype BoxCollider = typeof BoxCollider;\ntype Font = Record<string, ImageMask>;\ntype Button = 'up' | 'down' | 'left' | 'right' | 'u' | 'i' | 'o' | 'p';\ninterface Vec2 {\n    x: number;\n    y: number;\n}\n\ninterface Vec3 {\n    x: number;\n    y: number;\n    z: number;\n}\n\ninterface Vec4 {\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n}\n\ninterface Transform {\n    position: Vec2;\n}\n\ninterface Component<Config = void> {\n    init(config: Partial<Config> | undefined, gameObject: _GameObject): Config;\n    update?(config: Config, dt: number, gameObject: _GameObject): void;\n    remove?(config: Config, gameObject: _GameObject): void;\n    readonly name: string;\n}\n\ninterface GameObjectOptions {\n    name: string;\n    image: Image | string;\n    mask?: ImageMask | string;\n    components?: ComponentEntry<any>[];\n    opacity?: number;\n    transform?: Partial<Transform>;\n    customRenderer?: boolean;\n    events?: Record<string, (obj: GameObject, ...args: any[]) => void>;\n    eventsOnce?: Record<string, (obj: GameObject, ...args: any[]) => void>;\n}\ntype ComponentEntry<T> = {\n    component: Component<T>;\n    config?: Partial<T>;\n};\ninterface UserScene<T> {\n    beforeInit(scene: _Scene): T;\n    afterInit?(config: T, scene: _Scene): void;\n    beforeUpdate?(config: T, scene: _Scene, dt: number): void;\n    afterUpdate?(config: T, scene: _Scene, dt: number): void;\n    beforeRemove?(config: T, scene: _Scene): void;\n    afterRemove?(config: T, scene: _Scene): void;\n    gameObjects: _GameObject[];\n    name: string;\n}\ninterface Line {\n    readonly y: number;\n    readonly start: number;\n    readonly end: number;\n}\ntype ColorPalette = [\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string\n];\ninterface Image {\n    width: number;\n    height: number;\n    buf: Uint8Array;\n}\ninterface ImageMask {\n    width: number;\n    height: number;\n    buf: Uint8Array;\n}\n\ninterface GameFile {\n    name: string;\n    palette?: ColorPalette;\n    bg: string;\n\n    init?(): void;\n    update?(dt: number): void;\n    remove?(): void;\n    scenes?: _Scene[];\n    defaultScene?: number;\n}\n\n/**\n *\n * INTERNAL TYPES\n *\n */\n\ninterface _GameObject {\n    active: boolean;\n    addComponents<T>(components: ComponentEntry<T>[]): void;\n    transform: Transform;\n    image: Image;\n    mask?: ImageMask;\n    readonly name: string;\n    removeComponent(component: string): void;\n    getComponent<T extends Component<any>>(component: string): T | undefined;\n    getComponentData<T extends Component<any>>(\n        component: string\n    ): Required<Parameters<T['init']>[0]> | undefined;\n    remove(): void;\n    init(): void;\n    render(dt: number): void;\n\n    off(name: string, cb: (obj: GameObject, ...args: any[]) => void): void;\n    once(name: string, cb: (obj: GameObject, ...args: any[]) => void): void;\n    on(name: string, cb: (obj: GameObject, ...args: any[]) => void): void;\n    emitEvent(name: string, args: any[]): void;\n}\n\ninterface _Scene {\n    readonly name: string;\n    objects: _GameObject[];\n    init(): void;\n    remove(): void;\n    update(dt: number): void;\n    addObject(obj: _GameObject): void;\n    objectAmount(): number;\n    getObjectByName(name: string): GameObject | undefined\n    getObjectsByName(name: string): GameObject[]\n    removeObject(object: GameObject): void;\n    removeObjects(...objects: GameObject[]): void;\n    removeObjectByName(name: string): void;\n    removeObjectsByName(...names: string[]): void;\n}\ninterface _SceneManager {\n    setScenes(newScenes: _Scene[], defaultSelected?: number): void;\n    addScene(scene: _Scene): void;\n    changeScene(scene: string | number): void;\n    update(dt: number): void;\n    getScene<T>(): _Scene | undefined;\n}\ninterface _TextUtils {\n    calculateBounds(\n        text: string,\n        x: number,\n        y: number,\n        maxWidth: number,\n        options?: {\n            spaceWidth?: number;\n            centered?: boolean;\n        }\n    ): Line[];\n    calculateWidth(text: string, spaceWidth?: number): number;\n    writeText(\n        text: string,\n        x: number,\n        y: number,\n        maxWidth: number,\n        options?: {\n            color?: number;\n            background?: number;\n            spaceWidth?: number;\n            centered?: boolean;\n        }\n    ): Line[];\n    currentTextMasks: Font;\n    addCharacterMask(character: string, mask: ImageMask): void;\n    applyCharacterMap(map: Record<string, ImageMask | string>): void;\n    clearCharacterMap(): void;\n}\ninterface ImageUtils {\n    defaultPalette: ColorPalette;\n    getCurrentPalette(): ColorPalette;\n    setCurrentPalette(palette: ColorPalette): void;\n    parseImage(image: string): Image;\n    parseMask(content: string): ImageMask;\n    getColor(\n        color: number,\n        palette?: ColorPalette\n    ): Record<'r' | 'g' | 'b' | 'a', number>;\n    applyImageMask(image: Image, mask: ImageMask): Image;\n    applyImageMaskModifyImage(image: Image, mask: ImageMask): void;\n    stringifyImage(img: Image): string;\n    stringifyMask(mask: ImageMask): string;\n    imgToPng(\n        image: Image,\n        type?: 'image/png' | 'image/jpeg' | 'image/webp'\n    ): string;\n    putImage(x: number, y: number, image: Image): void;\n    putImageRaw(x: number, y: number, image: Image): void;\n    isValidColor(color: number): boolean;\n    square(width: number, height: number, color: number | string): Image;\n    circle(radius: number, color: number | string): Image;\n    serializeImage(img: Image): Uint8Array;\n    unserializeImage(arr: Uint8Array): Image;\n}\ninterface Utils {\n    nextFrame(): Promise<void>;\n    download(url: string, filename: string): Promise<void>;\n    isOnTimeout(name: string): boolean;\n    timeout(name: string, ms: number): void;\n}\ninterface SaveFileUtils {\n    storeToFile(obj: any, prefix?: string): void;\n    readFromFile<T>(prefix?: string): T | undefined;\n}\ninterface _Math {\n    distance(x: number, y: number): number;\n    lerp(p0: number, p1: number, t: number): number;\n}\ntype Math = _Math;\ntype GameObject = _GameObject;\ntype Scene = _Scene;\ntype SceneManager = _SceneManager;\ntype TextUtils = _TextUtils;\n\ntype gfxInstrument = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;\ntype Instrument =\n    | 'square-wave'\n    | 'sine-wave'\n    | 'triangle-wave'\n    | 'sawtooth-wave'\n    | 'noise'\n    | `gfx${gfxInstrument}`;\n\ninterface Audio {\n    channel1: Uint8Array;\n    channel2: Uint8Array;\n    channel3: Uint8Array;\n    channel4: Uint8Array;\n    channel1Instrument: Instrument;\n    channel2Instrument: Instrument;\n    channel3Instrument: Instrument;\n    channel4Instrument: Instrument;\n    length: number;\n}\n\ninterface Sound {\n    octave: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\n    sound: 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g';\n    halfToneStepUp: boolean;\n}\ntype SoundFunction = (\n    vol: number,\n    freq: number,\n    time: number\n) => Promise<void>;\ninterface AudioUtils {\n    readonly validNotes: string[];\n    readonly validInstruments: Instrument[];\n    /**\n     * Specs:\n     *\n     * file: \\<length>:\\<instrument1>:\\<instrument2>:\\<instrument3>:\\<instrument4>:\\<sounds-for-channel1>:\\<sounds-for-channel2>:\\<sounds-for-channel3>:\\<sounds-for-channel4>\n     *\n     * \\<length>: ([0-9]+)\n     *\n     * \\<sounds-for-channel#>: (\\<sound>{0,length})\n     *\n     * \\<sound>: ([A-G]\\[0-8](#| ))\n     *\n     * \\<instrument#>: ((square|sine|triangle|sawtooth)\\-wave|noise|gfx-([0-9]|10))\n     *\n     * **Example**\n     * ```plain\n     *   ⌄ instrument 1          ⌄ instrument 3          ⌄ channel 1 sounds              ⌄ channel 3 sound\n     * 5:square-wave:square-wave:sine-wave:sawtooth-wave:C4 D4 E4 F4 G4 :C5 D5 E5 F5 G5 :C4 D4 E4 F4 G4 :C4 D4 E4 F4 G4\n     * ^ length      ^ instrument 2        ^ instrument 4                ^ channel 2 sounds              ^ channel 4 sounds\n     * ```\n     */\n    parseAudio(text: string): Audio;\n    /**\n     * sound in memory:\n     *\n     * \\<3 bit: note identifier, 0-6 (a-g)>\\<4 bit: Octave Identifier, 0-8>\\<1 bit: go half-tone up>\n     */\n    getSound(sound: number): Sound | undefined;\n    soundToUint8(sound: Sound): number;\n    serializeAudio(audio: Audio): Uint8Array;\n    unserializeAudio(arr: Uint8Array): Audio;\n    playSquareTune(vol: number, freq: number, time: number): Promise<void>;\n    playSineTune(vol: number, freq: number, time: number): Promise<void>;\n    playSawtoothTune(vol: number, freq: number, time: number): Promise<void>;\n    playTriangleTune(vol: number, freq: number, time: number): Promise<void>;\n    playNoise(vol: number, freq: number, time: number): Promise<void>;\n    playTune(\n        vol: number,\n        freq: number,\n        time: number,\n        type: OscillatorType\n    ): Promise<void>;\n    getInstrumentSoundFunction(instrument: Instrument): SoundFunction;\n    getFrequency(sound: Sound): number;\n    playSound(\n        sound: Sound,\n        instrument: Instrument,\n        vol: number,\n        time: number\n    ): Promise<void>;\n    playAudio(audio: Audio, timePerNote: number, vol: number): Promise<void>;\n}\ninterface Particle {\n    end: number;\n    pos: Vec2;\n    image: Image;\n    gravity: number;\n    force: Vec2;\n    fallsOOB: boolean;\n}\n"