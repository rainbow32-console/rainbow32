export default "/**\n *\n * EXPORTS\n *\n */\ndeclare function registerGame(game: GameFile): void;\ndeclare const fonts: Record<\"default\" | \"default_monospace\" | \"legacy\", Font>;\ndeclare const imageUtils: ImageUtils;\ndeclare const audioUtils: AudioUtils;\ndeclare const utils: Utils;\ndeclare const ParticleSystem: {\n    addParticle: (life: number, pos: Vec2, size: number, color: number, gravity: number, force: Vec2, oob?: boolean) => Particle;\n    removeParticle: (p: Particle) => void;\n};\ndeclare const ImageRenderer: Component<void>;\ndeclare const createComponent: <T>(component: Component<T>, data?: Partial<T> | undefined) => ComponentEntry<T>;\ndeclare const component: <T>(component: Component<T>, data?: Partial<T> | undefined) => ComponentEntry<T>;\ndeclare const comp: <T>(component: Component<T>, data?: Partial<T> | undefined) => ComponentEntry<T>;\ndeclare const GameObject: new (opts: GameObjectOptions) => _GameObject;\ndeclare const memory: Uint8Array;\ndeclare const isPressed: (button: Button) => boolean;\ndeclare const buttons: Record<Button, {\n    down: boolean;\n    press: boolean;\n}>;\ndeclare const WIDTH: number;\ndeclare const HEIGHT: number;\ndeclare const stopGame: () => void;\ndeclare const reset: () => void;\ndeclare const math: _Math;\ndeclare const saveFile: SaveFileUtils;\ndeclare const Scene: new <T extends Record<string, any>>(scene: UserScene<T>) => _Scene;\ndeclare const SceneManager: _SceneManager;\ndeclare const TextUtils: _TextUtils;\n/**\n *\n * TYPES\n *\n */\ntype Font = Record<string, ImageMask>;\ntype Button = 'up' | 'down' | 'left' | 'right' | 'u' | 'i' | 'o' | 'p';\ninterface Vec2 {\n    x: number;\n    y: number;\n}\ninterface Vec3 {\n    x: number;\n    y: number;\n    z: number;\n}\ninterface Vec4 {\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n}\ninterface Transform {\n    position: Vec2;\n}\ninterface Component<Config = void> {\n    init(config: Partial<Config> | undefined, gameObject: _GameObject): Config;\n    update?(config: Config, dt: number, gameObject: _GameObject): void;\n    remove?(config: Config, gameObject: _GameObject): void;\n    readonly name: string;\n}\ninterface GameObjectOptions {\n    name: string;\n    image: Image | string;\n    mask?: ImageMask | string;\n    components?: ComponentEntry<any>[];\n    opacity?: number;\n    transform?: Partial<Transform>;\n    customRenderer?: boolean;\n}\ntype ComponentEntry<T> = {\n    component: Component<T>;\n    config?: Partial<T>;\n};\ninterface UserScene<T> {\n    beforeInit(scene: _Scene): T;\n    afterInit?(config: T, scene: _Scene): void;\n    beforeUpdate?(config: T, scene: _Scene, dt: number): void;\n    afterUpdate?(config: T, scene: _Scene, dt: number): void;\n    beforeRemove?(config: T, scene: _Scene): void;\n    afterRemove?(config: T, scene: _Scene): void;\n    gameObjects: _GameObject[];\n    name: string;\n}\ninterface Line {\n    readonly y: number;\n    readonly start: number;\n    readonly end: number;\n}\ntype ColorPalette = [\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string,\n    string\n];\ninterface Image {\n    width: number;\n    height: number;\n    buf: Uint8Array;\n}\ninterface ImageMask {\n    width: number;\n    height: number;\n    buf: Uint8Array;\n}\ninterface GameFile {\n    name: string;\n    palette?: ColorPalette;\n    bg: string;\n    init?(): void;\n    update?(dt: number): void;\n    remove?(): void;\n    scenes?: _Scene[];\n    defaultScene?: number;\n}\n/**\n *\n * INTERNAL TYPES\n *\n */\ninterface _GameObject {\n    active: boolean;\n    addComponents<T>(components: ComponentEntry<T>[]): void;\n    transform: Transform;\n    image: Image;\n    mask?: ImageMask;\n    opacity: number;\n    removeComponent(component: string): void;\n    getComponent<T extends Component<any>>(component: string): T | undefined;\n    remove(): void;\n    init(): void;\n    render(dt: number): void;\n}\ninterface _Scene {\n    readonly name: string;\n    init(): void;\n    remove(): void;\n    update(dt: number): void;\n    addObject(obj: _GameObject): void;\n}\ninterface _SceneManager {\n    setScenes(newScenes: _Scene[], defaultSelected?: number): void;\n    addScene(scene: _Scene): void;\n    changeScene(scene: string | number): void;\n    update(dt: number): void;\n    getScene<T>(): _Scene | undefined;\n}\ninterface _TextUtils {\n    calculateBounds(text: string, x: number, y: number, maxWidth: number, options?: {\n        spaceWidth?: number;\n        centered?: boolean;\n    }): Line[];\n    calculateWidth(text: string, spaceWidth?: number): number;\n    writeText(text: string, x: number, y: number, maxWidth: number, options?: {\n        color?: number;\n        background?: number;\n        spaceWidth?: number;\n        centered?: boolean;\n    }): Line[];\n    currentTextMasks: Font;\n    addCharacterMask(character: string, mask: ImageMask): void;\n    applyCharacterMap(map: Record<string, ImageMask | string>): void;\n    clearCharacterMap(): void;\n}\ninterface ImageUtils {\n    defaultPalette: ColorPalette;\n    getCurrentPalette(): ColorPalette;\n    setCurrentPalette(palette: ColorPalette): void;\n    parseImage(image: string): Image;\n    parseMask(content: string): ImageMask;\n    getColor(color: number, palette?: ColorPalette): Record<'r' | 'g' | 'b' | 'a', number>;\n    applyImageMask(image: Image, mask: ImageMask): Image;\n    applyImageMaskModifyImage(image: Image, mask: ImageMask): void;\n    stringifyImage(img: Image): string;\n    stringifyMask(mask: ImageMask): string;\n    imgToPng(image: Image, type?: 'image/png' | 'image/jpeg' | 'image/webp'): string;\n    putImage(x: number, y: number, image: Image): void;\n    putImageRaw(x: number, y: number, image: Image): void;\n    isValidColor(color: number): boolean;\n    square(width: number, height: number, color: number | string): Image;\n    circle(radius: number, color: number | string): Image;\n    serializeImage(img: Image): Uint8Array;\n    unserializeImage(arr: Uint8Array): Image;\n}\ninterface Utils {\n    nextFrame(): Promise<void>;\n    download(url: string, filename: string): Promise<void>;\n    isOnTimeout(name: string): boolean;\n    timeout(name: string, ms: number): void;\n}\ninterface SaveFileUtils {\n    storeToFile(obj: any, prefix?: string): void;\n    readFromFile<T>(prefix?: string): T | undefined;\n}\ninterface _Math {\n    distance(x: number, y: number): number;\n    lerp(p0: number, p1: number, t: number): number;\n}\ntype Math = _Math;\ntype GameObject = _GameObject;\ntype Scene = _Scene;\ntype SceneManager = _SceneManager;\ntype TextUtils = _TextUtils;\ntype gfxInstrument = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;\ntype Instrument = 'square-wave' | 'sine-wave' | 'triangle-wave' | 'sawtooth-wave' | 'noise' | `gfx${gfxInstrument}`;\ninterface Audio {\n    channel1: Uint8Array;\n    channel2: Uint8Array;\n    channel3: Uint8Array;\n    channel4: Uint8Array;\n    channel1Instrument: Instrument;\n    channel2Instrument: Instrument;\n    channel3Instrument: Instrument;\n    channel4Instrument: Instrument;\n    length: number;\n}\ninterface Sound {\n    octave: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\n    sound: 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g';\n    halfToneStepUp: boolean;\n}\ntype SoundFunction = (vol: number, freq: number, time: number) => Promise<void>;\ninterface AudioUtils {\n    readonly validNotes: string[];\n    readonly validInstruments: Instrument[];\n    /**\n     * Specs:\n     *\n     * file: \\<length>:\\<instrument1>:\\<instrument2>:\\<instrument3>:\\<instrument4>:\\<sounds-for-channel1>:\\<sounds-for-channel2>:\\<sounds-for-channel3>:\\<sounds-for-channel4>\n     *\n     * \\<length>: ([0-9]+)\n     *\n     * \\<sounds-for-channel#>: (\\<sound>{0,length})\n     *\n     * \\<sound>: ([A-G]\\[0-8](#| ))\n     *\n     * \\<instrument#>: ((square|sine|triangle|sawtooth)\\-wave|noise|gfx-([0-9]|10))\n     *\n     * **Example**\n     * ```plain\n     *   ⌄ instrument 1          ⌄ instrument 3          ⌄ channel 1 sounds              ⌄ channel 3 sound\n     * 5:square-wave:square-wave:sine-wave:sawtooth-wave:C4 D4 E4 F4 G4 :C5 D5 E5 F5 G5 :C4 D4 E4 F4 G4 :C4 D4 E4 F4 G4\n     * ^ length      ^ instrument 2        ^ instrument 4                ^ channel 2 sounds              ^ channel 4 sounds\n     * ```\n     */\n    parseAudio(text: string): Audio;\n    /**\n     * sound in memory:\n     *\n     * \\<3 bit: note identifier, 0-6 (a-g)>\\<4 bit: Octave Identifier, 0-8>\\<1 bit: go half-tone up>\n     */\n    getSound(sound: number): Sound | undefined;\n    soundToUint8(sound: Sound): number;\n    serializeAudio(audio: Audio): Uint8Array;\n    unserializeAudio(arr: Uint8Array): Audio;\n    playSquareTune(vol: number, freq: number, time: number): Promise<void>;\n    playSineTune(vol: number, freq: number, time: number): Promise<void>;\n    playSawtoothTune(vol: number, freq: number, time: number): Promise<void>;\n    playTriangleTune(vol: number, freq: number, time: number): Promise<void>;\n    playNoise(vol: number, freq: number, time: number): Promise<void>;\n    playTune(vol: number, freq: number, time: number, type: OscillatorType): Promise<void>;\n    getInstrumentSoundFunction(instrument: Instrument): SoundFunction;\n    getFrequency(sound: Sound): number;\n    playSound(sound: Sound, instrument: Instrument, vol: number, time: number): Promise<void>;\n    playAudio(audio: Audio, timePerNote: number, vol: number): Promise<void>;\n}\ninterface Particle {\n    end: number;\n    pos: Vec2;\n    image: Image;\n    gravity: number;\n    force: Vec2;\n    fallsOOB: boolean;\n}\n"